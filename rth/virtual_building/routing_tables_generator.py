from rth.virtual_building.utils import *
## @package routing_tables_generator
#
#  Contains the class that generates and formats the routing tables.


class RoutingTablesGenerator:
    """
    Generates and formats the routing tables of a network
    """

    def __init__(self, network_creator_instance, subnets, routers, links, hops, options=None):
        """
        Init

        Args:
            network_creator_instance: The NetworkCreator instance
            subnets: The subnetworks
            routers: The routers
            links: The links
            hops: The hops (paths) generated by the Ants system
            options: the options
        """

        self.ncinst = network_creator_instance
        # given basics
        self.subnets = subnets
        self.routers = routers
        self.equitemporality = True
        self.hops = hops
        self.links = links
        self.master_router = get_master_router(self.routers)

    @staticmethod
    def router_ip(instance_, provided):
        """
        Get a router IP if it is on the network

        Args:
            instance_: The subnetwork instance
            provided: The UID of the provided router

        Returns:
            The IP the router has been assigned if there is one, else False
        """

        return instance_.routers[provided] if provided in instance_.routers else False

    def build_paths_from_possibilites(self, routers_infos, outer_list, inner_list, return_as_dict=False):
        """
        Builds paths from the given lists

        Args:
            routers_infos: A list with the master router ID in 0 and the current router in 1
            outer_list: The subnetwork(s) to reach from the current router
            inner_list: The subnetwork(s) connected to the current router
            return_as_dict: (boolean) if the results are returned as a dict or only the
                first subnetwork of the smaller path is returned
        """

        paths_ = {} if return_as_dict else []

        for end in outer_list:
            inner_paths = []
            for start in inner_list:
                # we get the previously generated hop
                if start != end:
                    inner_paths.append(self.hops[(start, end)])
                else:
                    inner_paths.append([start])
            # we choose the smaller path out of every path in this list
            if (inner_paths[0] == [routers_infos[1]]) and (routers_infos[0] != routers_infos[1]):
                del inner_paths[0]
            if return_as_dict:
                paths_[end] = smaller_of_list(inner_paths)
            else:
                paths_.append(smaller_of_list(inner_paths))

        if return_as_dict:
            return paths_
        else:
            return smaller_of_list(paths_)[0]

    def try_router_connected_to_subnet(self, subnets, router_uid):
        """
        Try to see if the router is connected to the subnetwork

        Args:
            subnets: The subnetworks list
            router_uid: The router UID

        Returns:
            The IP the router is assigned on this subnetwork, and the UID of said subnetwork
        """

        ip_ = None
        sub = None
        for subnet_ in subnets:
            result = self.router_ip(self.subnets[subnet_]['instance'], router_uid)
            if result is not False:
                ip_ = result
                sub = subnet_
                break
        return ip_, sub

    def pick_subnet_between_two_routers(self, first, second):
        hops = [h for h in self.hops if h[0] == first and h[1] == second]
        singleton_paths = [self.hops[p] for p in hops if len(self.hops[p]) == 1]

        return singleton_paths[0][0]  # Return the first one because we didnt define the preferences yet

    def get_routing_table(self, router_id):
        """
        Get the routing table of corresponding router

        Args:
            router_id: The UID of the router

        Returns:
            The raw routing table for the router
        """

        routing_table = {}
        subnets_done = []
        subnets_attached = self.links['routers'][router_id]

        # starting off by listing attached subnets and getting their ip for this router
        for subnet in subnets_attached:
            inst_ = self.subnets[subnet]['instance']
            ip = self.router_ip(inst_, router_id)
            routing_table[inst_.cidr] = {
                'gateway': ip,
                'interface': ip
            }
            subnets_done.append(subnet)

        # getting master route

        # the subnetwork(s) attached to the master router
        master_attached = list(self.links['routers'][self.master_router])

        # if the master and this router share a subnetwork
        if any(i in master_attached for i in subnets_attached):
            # Then we get the master router IP and just put this as the gateway
            # Interface remains this router's IP
            subnet = master_attached[0]
            inst_ = self.subnets[subnet]['instance']
            routing_table['0.0.0.0/0'] = {
                "gateway": self.router_ip(inst_, self.master_router),
                "interface": self.router_ip(inst_, router_id)
            }
        else:
            # now retrieving the possible tuples between the subnetworks
            possible_hops = [h for h in self.hops if (h[0] in subnets_attached) and (h[1] in master_attached)]

            if not possible_hops:
                raise Exception(f"Could not find any hop that connect the master router to router id {router_id} "
                                f"'{self.ncinst.uid_to_name('router', router_id)})")

            # REMINDER:
            # Tuples are (x, y) with x and y being two subnetworks IDs
            # Hops are lists like [a, b, c, ...] with a, b, c, etc. being ROUTERS IDs

            # The hops from the selected tuples above
            possible_paths = [self.hops[p] for p in possible_hops]
            choices = dict(zip(possible_hops, possible_paths))
            # The tuple for which the number of hops is the lowest
            shorter = possible_hops[smaller_of_list(possible_paths, True)]

            # The starting subnetwork ID (so start of the tuple)
            starting_sid = shorter[0]
            # The first element of the hops list (so first router to hop onto next)
            guiding_router_id = choices[shorter][0]

            # The interface used (this router on the starting subnetwork)
            to_master_interface = self.ncinst.get_ip_of_router_on_subnetwork(starting_sid, router_id)
            if to_master_interface is None:
                raise Exception(f"Interface to master of router {router_id} should not be None")

            # Now we establish the gateway (ip of next router on the starting subnetwork)
            to_master_gateway = self.ncinst.get_ip_of_router_on_subnetwork(starting_sid, guiding_router_id)
            if to_master_gateway is None:
                raise Exception(f"Gateway to master of router {router_id} should not be None")

            routing_table['0.0.0.0/0'] = {
                "gateway": to_master_gateway,
                "interface": to_master_interface
            }

        # now we get each non-registered-yet subnet left
        subnets_left = [i for i in self.subnets
                        if self.subnets[i]['instance'].uid not in subnets_done]
        paths = self.build_paths_from_possibilites([self.master_router, router_id], subnets_left,
                                                   subnets_attached, return_as_dict=True)

        for subnet in subnets_left:
            router = paths[subnet][0]
            ip, subnet_id = self.try_router_connected_to_subnet(subnets_attached, router)
            if not ip:
                raise Exception(f"Router id {router} should have been found in at least one of the subnetworks")
            interface = self.ncinst.get_ip_of_router_on_subnetwork(subnet_id, router_id)
            if not interface:
                raise Exception(f"Could not find interface of router {router_id} on subnet {subnet_id}, though the "
                                f"router points to a gateway on this subnetwork")
            routing_table[self.subnets[subnet]['instance'].cidr] = {
                "gateway": ip,
                "interface": interface
            }

        return routing_table

    def calculate_better_path_from_delays(self):
        """
        Template of a future function.
        Not implemented yet. Raises NotImplementedError if called.

        Raises:
            Always raises NotImplementedError for now
        """

        raise NotImplementedError
